(* # ===================================================================
# Adequate-C Language Grammar Specification
# ===================================================================
# Format: BNF (Backus-Naur Form)
# File extension: .ebnf (for GitHub syntax highlighting)
# Note: Grammar is still being worked on and includes future features
#       that may not be implemented for v1.0
# =================================================================== *)

<program> ::= <import-stmt> <declaration-seq>
    ::= <declaration-seq>

<declaration-seq> ::= <main-function> <declaration>
    ::= <declaration> <main-function> <declaration>

<declaration> ::= ε
    ::= <namespace> <declaration>
    ::= <Struct> <declaration>
    ::= <function> <declaration>
    ::= <Enum> <declaration>


<import-stmt> ::= import <ident> <import-stmt-tail>
<import-stmt-tail> ::= ; <import-tail> 
    ::= . <ident> <import-stmt-tail>
<import-tail> ::= ε
    ::= <import-stmt>


<main-function>::= func main (<paramList>) <main-function-tail>

<main-function-tail> ::= -> void { <body> }
    ::= { <body> }

<namespace> ::= namespace <ident> { <declaration> }

<Struct> ::= struct <ident> <generic> { <Struct_body> }
<Struct_body> ::= ε
    ::= <VarDec> <Struct_body>
    ::= <struct-function> <Struct_body>
<struct-function> ::= <prototype> <struct-function-tail>
<struct-function-tail> ::= { <body> }
    ::= ;

<Enum> ::= enum <ident> : <Enum_allowed_type> { <Enum_body> }
<Enum_allowed_type> ::= int
<Enum_body> ::= <Ident> <Enum_body_tail>
<Enum_body_tail> ::= ε
    ::= = <Expr> <Enum_body_tail>
    ::= , <Enum_tail>
<Enum_tail> ::= ε
    ::= <ident> <Enum_body_tail>

<template> ::= template < <template-tail> >
<template-tail> ::= <template-constraint> : <ident> <template-tail>
    ::= , <template-constraint> : <ident> <template-tail>

<template-constraint> ::= numeric
    ::= integral
    ::= floating
    ::= signed
    ::= unsigned
    ::= comparable
    ::= orderable

<function> ::= <prototype> { <body> }
<prototype> ::= func <function-name> <generic> ( <paramList> ) -> <return-list>
<function-name> ::= <ident> <function-name-tail>
<function-name-tail> ::= ε
    ::= :: <ident> <function-name-tail>
<paramList> ::= ε
    ::= <type> <ident> <paramList_tail>
<paramList_tail> ::= ε
    ::= , <type> <ident> <paramList_tail>
<return-list> ::= <type>
    ::= union [ <type> <return-list-tail> ]
    ::= tuple [ <type> <return-list-tail> ]
<return-list-tail> ::= ε
    ::= , <type> <return-list-tail>

<generic> ::= ε
    ::= < <ident> <generic-tail> >
<generic-tail> ::= ε
    ::= , <ident> <generic-tail>

<body> ::= ε
    ::= <Stmt> <body>
    ::= <VarDec> <body>

<Stmt> ::= <IfStmt> <Stmt_tail>
    ::= <ForStmt> <Stmt_tail>
    ::= <WhileStmt> <Stmt_tail>
    ::= <DoStmt> <Stmt_tail>
    ::= <SwitchStmt> <Stmt_tail>
    ::= <ReturnStmt>
    ::= <BreakStmt> <Stmt_tail>
    ::= <AssignmentStmt> <Stmt_tail>

<Stmt_tail> ::= ε 
    ::= <Stmt> <Stmt_tail>

<IfStmt> ::= if ( <cond> ) { <body> } <IfStmt_tail>
<IfStmt_tail> ::= ε
    ::= else <elseStmt>
<elseStmt> ::= <IfStmt>
    ::= { <body> }

<ForStmt> ::= for ( <for_init> ; <cond> ; <Expr> ) { <body> }
<for_init> ::= <type> <AssignmentStmt>
    ::= <AssignmentStmt>

<WhileStmt> ::= while ( <cond> ) { <body> }

<DoStmt> ::= do { <body> } while ( <cond> )

<SwitchStmt> ::= switch ( <Switch_allowed_type> ) { <Switch_body> }
<Switch_body> ::= <case_list>
<case_list> ::= <case_clause> <case_list>
<case_clause> ::= case <Switch_allowed_literal> : <body>
    ::= default : <body>
<Switch_allowed_type> ::= int 
    ::= char
<Switch_allowed_literal> ::= Int_lit 
    ::= char_lit

<ReturnStmt> ::= return <ReturnStmt-tail>
<ReturnStmt-tail> ::= ;
    ::= <Expr> ;

<VarDec> ::= <type> <ident> <VarDec_tail>
<VarDec_tail> ::= ;
    ::= [ <additive-expression> ] = <Expr>;
    ::= = <Expr>;

<AssignmentStmt> ::= <ident> = <AssignmentStmt_tail> ;
<AssignmentStmt_tail> ::= <Expr>

<Expr> ::= <cond>

<cond> ::= <logical-or-expression> <cond-tail>
<cond-tail> ::= ε
    ::= ? <Expr> : <cond>

<logical-or-expression> ::= <logical-and-expression> <logical-or-expression-tail>
<logical-or-expression-tail> ::= ε
	::= || <logical-and-expression>

<logical-and-expression> ::= <inclusive-or-expression> <logical-and-expression-tail>
<logical-and-expression-tail> ::= ε
    ::= && <inclusive-or-expression>

<inclusive-or-expression> ::= <exclusive-or-expression> <inclusive-or-expression-tail>
<inclusive-or-expression-tail> ::= ε
        ::= | <exclusive-or-expression>

<exclusive-or-expression> ::= <and-expression> <exclusive-or-expression-tail>
<exclusive-or-expression-tail> ::= ε
        ::= ^ <and-expression>

<and-expression> ::= <equality-expression> <and-expression-tail>
<and-expression-tail> ::= ε
        ::= & <equality-expression>

<equality-expression> ::= <relational-expression> <equality-expression-tail>
<equality-expression-tail> ::= ε
    ::= == <relational-expression>
    ::= != <relational-expression>

<relational-expression> ::= <shift-expression> <relational-expression-tail>
<relational-expression-tail> ::= ε
      ::= < <shift-expression>
      ::= > <shift-expression>
      ::= <= <shift-expression>
      ::= >= <shift-expression>

<shift-expression> ::= <additive-expression> <shift-expression-tail>
<shift-expression-tail> ::= ε
    ::= << <additive-expression>
    ::= >> <additive-expression>

<additive-expression> ::= <multiplicative-expression> <additive-expression-tail>
<additive-expression-tail> ::= ε
    ::= + <multiplicative-expression>
    ::= - <multiplicative-expression>

<multiplicative-expression> ::= <cast-expression> <multiplicative-expression-tail>
<multiplicative-expression-tail> ::= ε
    ::= * <cast-expression>
    ::= / <cast-expression>
    ::= % <cast-expression>

<cast-expression> ::= <unary-expression> <cast-expression-tail>
<cast-expression-tail> ::= ε
    ::= ( <primitive-type> ) <cast-expression>

<unary-expression> ::= <postfix-expression> <unary-expression-tail>
<unary-expression-tail> ::= ε
    ::= <unary-operator> <cast-expression>

<postfix-expression> ::= <primary-expression> <postfix-expression-tail>
<postfix-expression-tail> ::= ε
    ::= [ <Expr> ]
    ::= ( <arg-list> )
    ::= . <ident>
    ::= :: <ident>
    ::= ++
    ::= --

<arg-list> ::=    ε 
    ::= <Expr> <arg-list-tail>
<arg-list-tail> ::= ε
    ::= , <Expr> <arg-list-tail>

<primary-expression> ::= <ident>
    ::= <literal>
    ::= ( Expr )

<type> ::= <primitive-type>
	::= const <type>
	::= static <type>
	::= comptime <type>
<primitive-type> ::= int 
    ::= string 
    ::= char 
    ::= bool 
    ::= float 
    ::= double
<type-list> ::= ε
    ::= , <type> <type-list>

<assignment-operator> ::= =
    ::= *=
    ::= /=
    ::= %=
    ::= +=
    ::= -=
    ::= <<=
    ::= >>=
    ::= &=
    ::= ^=
    ::= |=

<unary-operator> ::= &
    ::= *
    ::= +
    ::= -
    ::= ~
    ::= !

<literal> ::= string_lit
    ::= char_lit
    ::= Int_lit
    ::= true
    ::= false

